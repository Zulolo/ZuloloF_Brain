
#ifndef __RF_H
#define __RF_H

#ifdef __USED_BY_RF__
	#define __EXTERN_RF__

		/* Here is how the RF works:
	 * UP keeps monitoring if there is any valid frame available (CD, AM, DR should be all SET) on certain channel for 300ms.
	 * If yes, receive frame and continuously monitoring on this channel. If no, hop to next channel according to the hopping table.
	 *
	 * Down keeps transmitting frames every 100ms. If transmitting failed, (can not get valid response) down start hopping procedure.
	 * Hopping procedure is to trying burst transmitting ACK frame continuously.
	 * If transmitting failed, jump to next channel according to table and start to transmit again. 
	 * The TX&RX address is generated by some algorithm and is set at start up or during hopping
	 *
	 */
	#define NRF905_RX_ADDRESS_IN_CR							5
	#define NRF905_CMD_WC_MASK									0x0F
	#define NRF905_CMD_WC(unWR_CFG_ByteIndex)		((unWR_CFG_ByteIndex) & NRF905_CMD_WC_MASK)
	#define NRF905_CMD_RC_MASK									0x0F
	#define NRF905_CMD_RC(unRD_CFG_ByteIndex)		(((unRD_CFG_ByteIndex) & NRF905_CMD_RC_MASK) | 0x10)
	#define NRF905_CMD_WTP											0x20
	#define NRF905_CMD_RTP											0x21
	#define NRF905_CMD_WTA											0x22
	#define NRF905_CMD_RTA											0x23
	#define NRF905_CMD_RRP											0x24
	#define NRF905_CMD_CC(unPwrChn)							((unPwrChn) | 0x1000)
	#define CH_MSK_IN_CC_REG										0x01FF

	#define NRF905_TX_ADDR_LEN									4
	#define NRF905_RX_ADDR_LEN									4
	#define NRF905_RX_PAYLOAD_LEN								16
	#define NRF905_TX_PAYLOAD_LEN								NRF905_RX_PAYLOAD_LEN
	#define HOPPING_MAX_CD_RETRY_NUM						10
	#define EXEC_TSK_MAX_CD_RETRY_NUM						HOPPING_MAX_CD_RETRY_NUM
	#define CD_RETRY_DELAY_US										50
	
	#define NRF905_SAME_CHN_MAX_TIME						30000		// 300ms, (30000*10us)
	#define NRF905_MAX_CD_WAIT_TIME							NRF905_SAME_CHN_MAX_TIME	
	#define NRF905_MAX_AM_WAIT_TIME							5000		// 50ms, (5000*10us)
	#define NRF905_MAX_DR_WAIT_TIME							5000		// 50ms, (5000*10us)

	#define AFTER_SET_BURST_TX_MAX_DELAY_US			5000
	#define AFTER_SET_BURST_RX_MAX_CD_DELAY_US	10000
	#define AFTER_CD_MAX_AM_DELAY_US						5000
	#define AFTER_AM_MAX_DR_DELAY_US						5000
	#define ROUTINE_TASK_INTERVAL_US						500000

	#define NRF905_MAX_COMM_ERR_BEFORE_HOPPING	20

	#define GPIO_LEVEL_LOW											GPIO_PIN_RESET
	#define GPIO_LEVEL_HIGH											GPIO_PIN_SET

	#define ARRAY_SIZE(a) 											(sizeof(a) / sizeof((a)[0]))
	
	typedef enum _nRF905Modes {
		NRF905_MODE_PWR_DOWN = 0,
		NRF905_MODE_STD_BY,
		NRF905_MODE_RD_RX,
		NRF905_MODE_BURST_RX,
		NRF905_MODE_BURST_TX,
		NRF905_MODE_MAX
	}nRF905Mode_t;

	typedef enum _nRF905CommType {
		NRF905_COMM_TYPE_RX_PKG = 0,
		NRF905_COMM_TYPE_TX_PKG
	}nRF905CommType_t;
		
	enum _nRF905PinPosInModeLevel{
		NRF905_PWR_UP_PIN_POS = 0,
		NRF905_TRX_CE_PIN_POS,
		NRF905_TX_EN_PIN_POS,
		NRF905_TX_POS_MAX
	};
		
//	#define SET_NRF905_TX_EN_PIN				HAL_GPIO_WritePin(NRF905_TX_EN_GPIO_Port, NRF905_TX_EN_Pin, GPIO_PIN_SET)
//	#define RESET_NRF905_TX_EN_PIN			HAL_GPIO_WritePin(NRF905_TX_EN_GPIO_Port, NRF905_TX_EN_Pin, GPIO_PIN_RESET)
//	#define SET_NRF905_PWR_UP_PIN				HAL_GPIO_WritePin(NRF905_PWR_UP_GPIO_Port, NRF905_PWR_UP_Pin, GPIO_PIN_SET)
//	#define RESET_NRF905_PWR_UP_PIN			HAL_GPIO_WritePin(NRF905_PWR_UP_GPIO_Port, NRF905_PWR_UP_Pin, GPIO_PIN_RESET)
//	#define SET_NRF905_TRX_CE_PIN				HAL_GPIO_WritePin(NRF905_TRX_CE_GPIO_Port, NRF905_TRX_CE_Pin, GPIO_PIN_SET)
//	#define RESET_NRF905_TRX_CE_PIN			HAL_GPIO_WritePin(NRF905_TRX_CE_GPIO_Port, NRF905_TRX_CE_Pin, GPIO_PIN_RESET)
	#define SET_NRF905_SPI_CS_PIN				HAL_GPIO_WritePin(NRF905_CS_GPIO_Port, NRF905_CS_Pin, GPIO_PIN_SET)
	#define RESET_NRF905_SPI_CS_PIN			HAL_GPIO_WritePin(NRF905_CS_GPIO_Port, NRF905_CS_Pin, GPIO_PIN_RESET)
	
	typedef enum
	{
		PIN_CHANGE_TIMEOUT = -1,
		PIN_CHANGE_OK,
		PIN_CHANGE_ALREADY_MATCH
	} WAIT_PIN_CHANGE_RSLT_T;

	typedef enum _nRF905State {
		NRF905_STATE_STDBY = 0,
		NRF905_STATE_NO_CD,
		NRF905_STATE_HOPPING,
		NRF905_STATE_CD,
		NRF905_STATE_AM,
		NRF905_STATE_DR,
		NRF905_STATE_TXING,
		NRF905_STATE_RXING,
		NRF905_STATE_END
	}nRF905State_t;

			// MSB of CH_NO will always be 0
	static const uint8_t NRF905_CR_DEFAULT[] =	{0x4C, 0x0C,		// F=(422.4+(0x6C<<1)/10)*1; No retransmission; +6db; NOT reduce receive power
		(NRF905_RX_ADDR_LEN << 4) | NRF905_TX_ADDR_LEN,	// 4 bytes RX & TX address;
		NRF905_RX_PAYLOAD_LEN,
		NRF905_TX_PAYLOAD_LEN, 	// 16 bytes RX & TX package length;
		0x00,
		0x0C,
		0x40,
		0x08,	// RX address is the calculation result of CH_NO
		0x58};	// 16MHz crystal; enable CRC; CRC16

	static const uint16_t unRF_HOPPING_TABLE[] = {	0x884C, 0x883A, 0x8846, 0x8832, 0x884A, 0x8835,
													0x884B, 0x8837, 0x884F, 0x883E, 0x8847, 0x8838,
													0x8844, 0x8834, 0x8843, 0x8834, 0x884B, 0x8839,
													0x884D, 0x883A, 0x884E, 0x883C, 0x8832, 0x883F};
	
	static const GPIO_PinState unNRF905MODE_PIN_LEVEL[][NRF905_TX_POS_MAX] = {{GPIO_LEVEL_LOW, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
																																						{GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
																																						{GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW, GPIO_LEVEL_LOW},
																																						{GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH, GPIO_LEVEL_LOW},
																																						{GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH, GPIO_LEVEL_HIGH}};
#else
	#define __EXTERN_RF__ extern
#endif
typedef struct _remoteControlMap {
	uint32_t unNRF905CommRecvFrameErr;
	uint32_t unNRF905CommRecvFrameErrTotal;
	uint32_t unNRF905CommRecvFrameOK;
	uint32_t unNRF905ChNoAndPwr;
	uint32_t unNRF905RX_Address;
}RemoteControlMap_t;

__EXTERN_RF__ RemoteControlMap_t tRemoteControlMap;
#endif
